---
title: 'Auth in my PF project'
publishedAt: '2023-01-12'
description: 'Fetching, cashing and protecting routes. Using React use-Query, we can write clean and consistent way of handling Server data in our Client.'
coverImage: ''
comment: 'Auth is an essential part of applications. Building it can be simple and satisfying.'
---

## What do we working with?

* Client - Next JS
* Server - Pyhton FastApi

Our backend using JWT tokens as an **access token**
with rotation of **refresh tokens**


## Libraries


On the clinet side I use [Tanstack React Query](https://react-query-v3.tanstack.com) to
fetch and cashe user session data

* [React-Query](https://react-query-v3.tanstack.com) - elegant layer for everething related to fetching and cashing
Everything is intuitive and handled with a very little amount of code.

* Axios for http requests - cleaner and nicely combines with React-useQuery


## Approach


To fetch and cache session information, I use the following approach:

- every API call that does not have an effect on cached entity data is expressed as an 'action' function -
  wrapper that handles API call and response

```typescript:authActions.ts showLineNumbers
  async function login(credentials){
    try {
      const { data, status } = await apiLoginUser(credentials);
      presistTokens(data.tokens)
      return { status: status };

    } catch (error) {
      hanldeError(error.response.status )
      return { status: error.response.status };
    }
  }
```

- every API call that influences a cached entity in-app is a custom hook that wraps a react-query hook -
  custom hook that wraps a react-query hook.
  That way we define all query preferences once and don't repeat ourselves.
  All `useQuery` states and methods remain exposed thru our custom hook.

```typescript:useAuth.tsx showLineNumbers
function useAuth(){
  return useQuery('user', getSession, {
    enabled: false, // needed to handle refetchs manually
    retry: false,
    staleTime: 60 * (60 * 1000), // 60 min
    onSuccess: (data) => {
      /* success callback */
    },
    onError: () => {
      /* error callback */
    },
    /* `select` will be returned `data` when accessing query results */
    select: (data) => formatResponse(data),
  });
};
```

Each time the Client will make a request for protected page/data - we do request on the Server.
No need to store User data in React state.

Login pattern:

1. Our `login`(action) `POST` user credentials and receives JWT
2. Short-lived JWT is encoded and stored and being sent with each protected API call
3. On successful `login`, we invalidate ['user'] query and trigger re-fetching
   in custom hook `useAuth()` that requests current user session
4. Each component that depends on the user session will be updated based on `useAuth()` query result

## Components examples

```typescript:Login.tsx showLineNumbers
function Login(){
    ...
    const queryClient = useCashedClient();

    async function onLoginSubmit(e: FormEvent<HTMLFormElement>) {
        e.preventDefault();

        const { status } = await login({ username, password });

        if (status === 200) {
          /* invalidate query cashe and trigger and refetch */
          queryClient.invalidateQueries(['user']);
          refetch();
        }
    }

    return (
        <form onSubmit={onLoginSubmit}>
            ...
        </form>
    )
}
```

```typescript:Navbar.tsx showLineNumbers
function Navbar() {
  const { data: user, isLoading } = useAuth();

  if (isLoading) return <Loading />;

  if (error) return <LoginButton />;

  return <UserAvatar />;
}
```

## Page protection

Each protected page has `requireAuth:boolean` property.

```typescript:cabinet.tsx showLineNumbers
export default function CabinetPage() {
  return (
      <CabinetPageProvider>
        <Cabinet />
      </CabinetPageProvider>
  );
}
/* setting  requireAuth to check in _app.tsx*/
CabinetPage.requireAuth = true;
```

1. In \_app.tsx we check if Component requires Auth

```typescript:_app.tsx
  ...
  <>
      {/* if requireAuth property is present - protect the page */}
      { Component.requireAuth ? (
      <AuthGuard>
        <Component {...pageProps} />
      </AuthGuard>
      ) : (
      /* public page */
      <LoginFormProvider>
        <Component {...pageProps} />
      </LoginFormProvider>
      )}
  </>
  ...
```

2. If Component.requireAuth === true -> we render `Component` wrapped in AuthGuard
   `AuthGuard` is wrapper, where we are isolatated page protection logic:

- Checking if user is logged in
- Showing loading state when user is fetching
- Retirecting to `/signup` when user is not logged in

That way we drop necessity to check if user is logged on each protected page

```typescript:AuthGuard.tsx showLineNumbers
export function AuthGuard({ children }: { children: JSX.Element }) {
  const { data: user, isLoading, isFetching } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if(!isLoading && !isFetching) return;
    if (!user) {
      setRedirect(router.route);
      router.push('/signup');
    }
  }, [isLoading, user, isFetching]);

  /* show loading indicator while the auth provider is still isLoading */
  if (isLoading || isFetching) return <Loading />;

  /* if auth initialized with a valid user show protected page  */
  if (user) return <>{children}</>;

  /* otherwise don't return anything, will do a redirect from useEffect */
  return null;
}
```
