---
title: 'How I implemented Auth in PF project'
publishedAt: '2023-01-12'
description: 'Fetching, cahing and protecting routes'
coverImage: ''
---

# Approach

Our backend using JWT tokens as an **access token** with rotation of **refresh tokens**

On the clinet side I use [Tanstack React Query](https://react-query-v3.tanstack.com) to
fetch and cashe user session data

React Query library provides an abstraction layer for handling everything that
related to an API call from API state(loading/fetching, isSuccess, isError, etc) to easily handle database mutations.\
Everything that is fetched with React Query is stored in the cache layer provided by the library.\
It can fulfill all our needs for **authentification**
Everything is super simple and handled with a very little amount of code.

Quick example from the docs:

```typescript showLineNumbers
import { QueryClient, QueryClientProvider, useQuery } from 'react-query';

const queryClient = new QueryClient();

export default function App() {
  return (
    /* React Query Client instance wraps component */
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  );
}

function Example() {
  const fetcher = fetch(
    'https://api.github.com/repos/tannerlinsley/react-query'
  ).then((res) => res.json());

  const { isLoading, error, data } = useQuery('repoData', fetcher);

  if (isLoading) return 'Loading...';

  if (error) return 'An error has occurred: ' + error.message;

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
    </div>
  );
}
```

To fetch and cache session information, I use the following approach:

- every API call that does not have an effect on cached entity data is expressed as an 'action' function -
  wrapper that handles API call and response

- every API call that influences a cached entity in-app is a custom hook that wraps a react-query hook -
  custom hook that wraps a react-query hook.
  That way we define all query preferences once and don't repeat ourselves.
  All `useQuery` states and methods remain exposed thru our custom hook.

Login pattern:

1. `login`(action) `POST` user credentials and receives JWT
2. Short-lived JWT is being encoded and stored in localStorage
   and being sent with each protected API call
3. On successful `login`, we invalidate ['user'] query and trigger re-fetching
   in custom hook `useAuth()` that requests current user session
4. Each component that depends on the user session will be updated based on `useAuth()` query result

## Code examples

```typescript:authActions.ts showLineNumbers
export async function login(
  credentials
){
  try {
    const { data, status } = await apiLoginUser(credentials);
    Storage.set('accessToken', data.access_token);
    Storage.set('refreshToken', data.refresh_token);
    return { status: status };
  } catch (error) {
    error.response.status === 404
      ? toast.error(error.response.data.detail.message)
      : toast.error('An unexpected error occurred :(  Try again.');
    return { status: error.response.status };
  }
}
```

---

```typescript:Login.tsx showLineNumbers
function Login(){
    ...
    const queryClient = useCashedClient();

    async function onLoginSubmit(e: FormEvent<HTMLFormElement>) {
        e.preventDefault();

        const { status } = await login({ username, password });

        if (status === 200) {
        /* invalidate query to trigger update cashed user */
        queryClient.invalidateQueries(['user']);
        refetch();
        }
    }

    return (
        <form onSubmit={onLoginSubmit}>
            ...
        </form>
    )
}
```

```typescript:useAuth.tsx showLineNumbers
export const useAuth = () => {
  return useQuery('user', getSession, {
    enabled: false, // needed to handle refetchs manually
    retry: false,
    onSuccess: (data) => {
      /* success callback */
    },
    onError: () => {
      /* error callback */
    },
    select: (data) => formatResponse(data), // will return in const { data } = useAuth()
  });
};
```

```typescript:Navbar.tsx showLineNumbers
function Navbar() {
  const { data: user, isLoading } = useAuth();

  if (isLoading) return <Loading />;

  if (error) return <LoginButton />;

  return <UserAvatar />;
}
```

### Page Auth protection

Each protected page has `requireAuth:boolean` property.

1. In \_app.tsx we check if Component requires Auth
2. If Component.requireAuth === true -> we render `Component` wrapped in AuthGuard
3. if auth is note required -> render just `Component`

```typescript:_app.tsx
  ...
  <>
      {/* if requireAuth property is present - protect the page */}
      { Component.requireAuth ? (
      <AuthGuard>
        <Component {...pageProps} />
      </AuthGuard>
      ) : (
      /* public page */
      <LoginFormProvider>
        <Component {...pageProps} />
      </LoginFormProvider>
      )}
  </>
  ...
```

Example of protected page:

```typescript:cabinet.tsx showLineNumbers
export default function CabinetPage() {
  return (
      <CabinetPageProvider>
        <Cabinet />
      </CabinetPageProvider>
  );
}
/* setting  requireAuth to check in _app.tsx*/
CabinetPage.requireAuth = true;
```

### AuthGuard

`AuthGuard` is wrapper, where we are isolatated page protection logic:

1. Checking if user is logged in
2. Showing loading state when user is fetching
3. Retirecting to `/signup` when user is not logged in

```typescript:AuthGuard.tsx showLineNumbers
export function AuthGuard({ children }: { children: JSX.Element }) {
  const { data: user, isLoading, isFetching } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !isFetching) {
      if (!user) {
        setRedirect(router.route);
        router.push('/signup');
      }
    }
  }, [isLoading, user, isFetching]);

  /* show loading indicator while the auth provider is still isLoading */
  if (isLoading || isFetching) {
    return <Loading />;
  }

  /* if auth initialized with a valid user show protected page  */
  if (user) {
    return <>{children}</>;
  }

  /* otherwise don't return anything, will do a redirect from useEffect */
  return null;
}
```
